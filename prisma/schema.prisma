generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}

model exchangerate {
  id            Int      @id @default(autoincrement())
  baseCurrency  String
  quoteCurrency String
  rate          Decimal
  fetchedAt     DateTime @default(now())
}

model fiatdeposit {
  id            Int                @id @default(autoincrement())
  userId        Int                @unique(map: "FiatDeposit_userId_key")
  amountTRY     Decimal
  convertedUSDT Decimal?
  bankRef       String?
  status        fiatdeposit_status @default(PENDING)
  createdAt     DateTime           @default(now())
  user          user               @relation(fields: [userId], references: [id], map: "FiatDeposit_userId_fkey")
}

model kycverification {
  id             Int                  @id @default(autoincrement())
  userId         Int
  type           kycverification_type
  fullName       String?
  companyName    String?
  documentType   String?
  documentNumber String?
  verified       Boolean              @default(false)
  verifiedAt     DateTime?
  createdAt      DateTime             @default(now())
  user           user                 @relation(fields: [userId], references: [id], map: "KycVerification_userId_fkey")

  @@index([userId], map: "KycVerification_userId_fkey")
}

model network {
  id          Int      @id @default(autoincrement())
  name        String
  symbol      String   @unique(map: "Network_symbol_key")
  chainId     String
  rpcUrl      String
  explorerUrl String?
  token       token[]
  wallet      wallet[]
}

model token {
  id                Int                 @id @default(autoincrement())
  networkId         Int
  symbol            String
  name              String
  contractAddr      String?
  decimals          Int
  isStablecoin      Boolean             @default(false)
  bridgetransaction bridgetransaction[]
  network           network             @relation(fields: [networkId], references: [id], map: "Token_networkId_fkey")
  tokenbalance      tokenbalance[]
  transaction       transaction[]

  @@index([networkId], map: "Token_networkId_fkey")
}

model tokenbalance {
  id        Int      @id @default(autoincrement())
  walletId  Int
  tokenId   Int
  amount    Decimal  @default(0.000000000000000000000000000000)
  updatedAt DateTime
  token     token    @relation(fields: [tokenId], references: [id], map: "TokenBalance_tokenId_fkey")
  wallet    wallet   @relation(fields: [walletId], references: [id], map: "TokenBalance_walletId_fkey")

  @@index([tokenId], map: "TokenBalance_tokenId_fkey")
  @@index([walletId], map: "TokenBalance_walletId_fkey")
}

model transaction {
  id          Int                    @id @default(autoincrement())
  walletId    Int
  userId      Int
  tokenId     Int?
  type        transaction_type
  amount      Decimal
  txHash      String?                @unique(map: "Transaction_txHash_key")
  status      transaction_status     @default(PENDING)
  fromAddress String
  toAddress   String
  createdAt   DateTime               @default(now())
  direction   transaction_direction?
  explorerUrl String?
  usdValue    Decimal?
  fee         Decimal                @default(0.000000000000000000000000000000)
  token       token?                 @relation(fields: [tokenId], references: [id], map: "Transaction_tokenId_fkey")
  user        user                   @relation(fields: [userId], references: [id], map: "Transaction_userId_fkey")
  wallet      wallet                 @relation(fields: [walletId], references: [id], map: "Transaction_walletId_fkey")

  @@index([tokenId], map: "Transaction_tokenId_fkey")
  @@index([userId], map: "Transaction_userId_fkey")
  @@index([walletId], map: "Transaction_walletId_fkey")
}

model user {
  id                Int                 @id @default(autoincrement())
  email             String              @unique(map: "User_email_key")
  password_hash     String
  role              UserRole            @default(user)
  createdAt         DateTime            @default(now())
  updatedAt         DateTime?           @default(now())
  full_name         String
  bridgetransaction bridgetransaction[]
  fiatdeposit       fiatdeposit?
  kycverification   kycverification[]
  transaction       transaction[]
  wallet            wallet[]
}

model wallet {
  id            Int                 @id @default(autoincrement())
  userId        Int
  networkId     Int
  address       String              @unique(map: "Wallet_address_key")
  privateKeyEnc String              @db.Text
  meta          String?             @db.Text
  createdAt     DateTime            @default(now())
  bridgeFrom    bridgetransaction[] @relation("BridgeFromWallet")
  bridgeTo      bridgetransaction[] @relation("BridgeToWallet")
  tokenbalance  tokenbalance[]
  transaction   transaction[]
  network       network             @relation(fields: [networkId], references: [id], map: "Wallet_networkId_fkey")
  user          user                @relation(fields: [userId], references: [id], map: "Wallet_userId_fkey")

  @@index([networkId], map: "Wallet_networkId_fkey")
  @@index([userId], map: "Wallet_userId_fkey")
}

model bridgetransaction {
  id              Int           @id @default(autoincrement())
  userId          Int
  fromWalletId    Int
  toWalletId      Int
  tokenId         Int
  fromChain       String
  toChain         String
  amount          Decimal       @db.Decimal(36, 18)
  status          bridge_status @default(INITIATED)
  fromTxHash      String?       @db.VarChar(255)
  toTxHash        String?       @db.VarChar(255)
  explorerUrlFrom String?       @db.Text
  explorerUrlTo   String?       @db.Text
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt
  bridgeFee       Decimal?      @db.Decimal(36, 18)
  completedAt     DateTime?
  errorMessage    String?       @db.Text
  estimatedTime   Int?
  fromWallet      wallet        @relation("BridgeFromWallet", fields: [fromWalletId], references: [id])
  toWallet        wallet        @relation("BridgeToWallet", fields: [toWalletId], references: [id])
  token           token         @relation(fields: [tokenId], references: [id])
  user            user          @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([fromWalletId])
  @@index([toWalletId])
  @@index([tokenId])
  @@index([status])
  @@index([createdAt])
  @@index([fromTxHash])
  @@index([toTxHash])
}

enum bridge_status {
  INITIATED
  LOCKED
  CONFIRMED
  MINTED
  COMPLETED
  FAILED
}

enum kycverification_type {
  PERSONAL
  CORPORATE
}

enum transaction_type {
  DEPOSIT
  WITHDRAW
  TRANSFER
  CONVERT
}

enum fiatdeposit_status {
  PENDING
  COMPLETED
  FAILED
}

enum transaction_status {
  PENDING
  CONFIRMED
  FAILED
}

enum transaction_direction {
  SENT
  RECEIVED
}

enum UserRole {
  user
  admin
}